# CS_study_10회

## 1. [개발상식] OOP

> OOP의 특징과 5대 원칙에 대해 설명하시오.

OOP의 특징은 필요한 데이터를 추상화 시켜 상태와 행위를 가진 객체로 프로그램을 구성한다는 것입니다. 객체 간의 상호작용을 통해 로직을 구성하기 때문에 재사용이 용이하고 유지보수가 쉽습니다.

이러한 OOP의 5대 원칙에 대해 말씀드리겠습니다.

첫째, 단일 책임의 원칙(SRP)입니다. 클래스는 한 가지 기능만 가지며 한 가지 책임을 수행하는데 집중되어야 한다는 것입니다. 이러한 원칙을 따르면 클래스를 여러가지로 분할하여 유연하게 설계할 수 있습니다.

둘째, 개방 폐쇄의 원칙(OCP)입니다. 소프트웨어의 구성요소는 확장에는 열려있으나, 변경에는 닫혀있어야 한다는 것입니다. 추가 사항이 발생하더라도 기존 구성은 변경하지 않지만 확장에 대한 가능성은 열어두어야 한다는 것입니다.

셋째, 리스코브 치환의 원칙(LSP)입니다. 사용자의 관점에서 기능에 영향을 미치지 않고 자식 클래스를 부모 클래스로 대체할 수 있어야 한다는 것입니다. 이는 상속의 기본적인 원리입니다.

넷째, 인터페이스 분리의 원칙(ISP)입니다. 한 클래스는 자신이 사용하지 않는 인터페이스는 구현하지 말아야 한다는 것입니다. 인터페이스를 분리함으로써 의존성을 약화시켜 리팩토링이 용이해집니다.

다섯째, 의존성 역전의 원칙(DIP)입니다. 고 수준 모듈은 저 수준 모듈에 의존하면 안 된다, 즉 하위 레벨에서의 변경으로 인해 상위 레벨이 영향받으면 안 된다는 것입니다. 이 원칙을 준수하면 유지 관리가 편해지지만, 새로운 클래스 구현이 어려울 수 있습니다.



## 2. [알고리즘] 정렬

> 퀵 정렬과 머지 정렬 힙 정렬 등 알고있는 정렬을 말하고 차이를 설명하시오.

버블정렬, 선택정렬, 퀵정렬, 병합정렬에 대해서 말씀드리겠습니다.

### 1. 버블정렬

인접한 두 요소의 크기를 비교하여 앞의 요소가 뒷 요소보다 더 큰 경우, 서로의 값을 교환하는 방식으로 정렬하는 방식입니다. 시간복잡도는 O(N^2) 입니다. 코드 구현이 쉽고 직관적이지만, 모든 인접 값을 비교하므로 비효율적입니다.



### 2. 선택정렬

데이터 중 최솟값을 선택하여 가장 앞자리의 요소와 교환하는 방식으로 정렬합니다. 시간복잡도는 O(N^2)입니다. 버블 정렬보다는 일반적으로 2~3배 빠르지만 여전히 속도가 느리다는 단점을 가지고 있습니다.



### 3. 퀵정렬

가장 처음/중간/마지막 수 중 하나를 첫번째 피벗으로 선택하고, 피벗을 기준으로 왼쪽에 피벗보다 작은 수, 오른쪽에 피벗보다 큰 수를 배치하여 피벗이 자신의 자리를 찾게 됩니다. 이 후 양 쪽을 각각 퀵정렬 하는 분할정복의 방법을 사용하여 정렬을 완료하는 방식입니다.

퀵정렬의 시간복잡도는 피벗 선택에 따른 속도 편차가 크며, 최악의 경우 O(n^2)가 됩니다. 하지만 실제 사용 환경에서 가장 빠르다고 알려져 있습니다.



### 4. 병합정렬

요소를 더 이상 쪼갤 수 없을 때까지 절반씩 나눈 후, 정렬을 진행하는 분할정복 방식의 정렬 방법입니다. 재귀 형태로 구현하기 쉬운 방식이며 시간복잡도는 O(NlogN)입니다. 퀵정렬과 달리 pivot 선택 과정이 없기 때문에 항상 일정한 속도를 가지고 있습니다. 가장 많이 사용되는 정렬 알고리즘입니다.



## 3. [네트워크] DNS 서버

> DNS 서버란 무엇인가?

DNS란 Domain Name System으로 머신이 읽을 수 있는 IP 주소를 `www.google.com`과 같이 사람이 읽을 수 있는 도메인 이름으로 변환하는 시스템입니다.

컴퓨터는 IP주소와 같이 숫자를 이용하여 통신하지만, 이러한 IP주소는 사람이 기억하기 쉽지 않기 때문에 도메인 이름을 사용합니다. DNS는 이러한 IP주소와 도메인을 매칭해주는 일종의 전화번호부와 같다고 할 수 있습니다. 더 나아가 DNS 서버는 사용자로부터 도메인에 대한 요청이 들어오면 이를 IP 주소로 변환한 후, 해당 사용자를 어떤 서버에 연결할 지 제어합니다.



참고: https://aws.amazon.com/ko/route53/what-is-dns/



## 4. [파이썬] is / ==

> Python에서 is와 ==의 차이를 설명하시오.

`is`는 변수가 같은 객체를 가리키면 True이며, `==`는 변수가 같은 값을 가지면 True입니다.

```python
a = [1, 2, 3]
b = a
c = [1, 2, 3]

print(a is b) # True
print(a is c) # False
print(a == b) # True
print(a == c) # True
```

이러한 예제에서 `a is c`가 `False`인 이유는 `a`, `c`가 값은 `[1, 2, 3]`으로 같지만 서로 다른 객체를 가리키기 때문입니다. 반면 `a is b`가 `True`인 이유는 리스트인 `a`가 `b`에 할당되었을 때 `b`는 `a`와 같은 리스트를 가리키게 되기 때문입니다.

`a == b`와 `a == c`가 모두 `True`인 이유는 `a`, `b`, `c` 모두 `[1, 2, 3]` 이라는 같은 값을 가지기 때문입니다.
