# CS_study_12회

## 1. [네트워크] 프록시

> 프록시란 무엇인가요?

프록시(proxy)라는 단어는 '대리인'이라는 뜻을 가지고 있습니다. 즉, 네트워크에서의 프록시란 클라이언트를 대신하여 다른 네트워크 서비스에 간접적으로 접속할 수 있게 해주는 서버를 뜻합니다.

프록시 서버는 요청된 내용들을 캐시를 이용하여 저장합니다. 이후 동일한 요청이 들어오면 프록시 서버의 캐시에 저장된 정보를 불러오기 때문에 서버의 부하를 줄일 수 있고, 사용자의 요청에 빠르게 응답할 수 있습니다. 또한, 외부와의 트래픽을 줄일 수 있으므로 네트워크 병목 현상을 방지하는 효과도 가지게 됩니다.



## 2. [웹] V8 & Node.js

> V8 엔진과 Node.js에 대해 아는만큼 설명해주세요.

V8엔진은 구글이 제공하는 오픈소스 자바스크립트 엔진입니다. 자바스크립트 코드를 CPU가 이해할 수 있는 기계어로 변환해주는 역할을 합니다. V8엔진은 C++로 작성됐으며, 단독으로 동작할 수 있는 동시에 C++로 구현된 함수를 자바스크립트의 새로운 특성으로 넣을 수 있다는 특징을 가지고 있습니다. 예를들어 `print('hello world')`는 자바스크립트에서 실행할 수 없지만, C++로 `print`의 기능을 구현함으로써 자바스크립트 환경에서도 `print`문을 native로 사용할 수 있게 되는 것입니다.



Node.js는 이러한 V8 엔진으로 만들어진 자바스크리트 런타임입니다. 즉, 자바스크립트 프로그램을 컴퓨터에서 실행할 수 있게 해주는 환경입니다. 기존의 자바스크립트는 브라우저에서만 실행할 수 있는 한계점이 있었지만, Node.js로 인해 컴퓨터에서도 실행될 수 있게 되었습니다.

Node.js는 V8 엔진과 libuv라는 라이브러리로 이루어져있습니다. libuv 라이브러리는 Node.js의 특성인 이벤트 기반, 논 블로킹 I/O 모델을 구현하고 있습니다. 이벤트 기반이란 이벤트가 발생할 때 미리 지정한 작업을 수행하는 것입니다. 논 블로킹 I/O 란 이전 작업이 완료될 때까지 입출력을 대기하는 것이 아니라 동시에 실행하는 것입니다.



## 3. [DB] 트랜잭션 격리 수준

> 트랜잭션 격리 수준에 대해 아시나요?

트랜잭션 격리 수준이란 DB에서 동시에 여러 트랜잭션이 처리될 때, 특정 트랜잭션이 다른 트랜잭션의 변경된 데이터를 볼 수 있는 정도를 뜻합니다.

DB는 무결성을 지키기 위해 동시에 처리되는 트랜잭션이 서로의 영향을 받지 못하도록 Locking을 할 수 있습니다. 그러나 모든 트랜잭션 처리에 대해 Locking 하게 되면 DB의 성능이 떨어지기 때문에 다양한 수준을 두고 Locking의 정도를 세분화했습니다. 이것이 바로 트랜잭션 격리 수준입니다.

1. Read Uncommitted (레벨 0): 다른 트랜잭션이 현재 처리중인 트랜잭션이나 아직 Commit되지 않은 데이터를 읽는 것을 허용합니다. DB 처리의 동시성은 높아지지만 데이터의 일관성을 유지하는 것이 불가능합니다.
2. Read Committed (레벨 1): SELECT 문장이 수행되는 동안 해당 데이터에 Shared Lock이 걸립니다. 즉, 트랜잭션이 처리되는 동안은 다른 트랜잭션이 접근할 수 없기 때문에 Commit이 이루어진 트랜잭션만 접근할 수 있습니다. Oracle에서 기본적으로 사용하는 수준입니다.
3. Repeatable Read (레벨 2): 트랜잭션이 완료될 때까지 SELECT 문장이 사용되는 모든 데이터에 Shared Lock이 걸립니다. 다른 사용자는 트랜잭션 영역에 해당하는 데이터에 대한 수정이 불가능합니다. My SQL에서 기본적으로 사용하는 수준입니다.
4. Serializable (레벨 3): 레벨 2에서 더 나아가 트랜잭션 영역에 해당하는 데이터에 대한 수정 및 입력이 불가능합니다. 따라서 완벽한 읽기 일관성 모드를 제공합니다.

격리 수준이 높아질 수록 트랜잭션간 고립 정도가 높아지기 때문에 DB 성능이 저하됩니다.



## 4. [운영체제] 세마포어 & 뮤텍스

> 다수의 프로세스나 스레드가 공유 자원에 동시에 접근하는 것을 제어하는 방법을 설명해주세요.

세마포어와 뮤텍스가 있습니다.

먼저 세마포어는 세마포어 변수, semWait 연산, semSignal연산으로 이루어져 있습니다. 세마포어 변수는 정수로 해당 정수 값 만큼 사용자 동시 접근을 할 수 있습니다. semWait연산은 세마포어 값을 감소시킵니다. 값이 음수가 되면 semWait를 호출한 프로세스는 블록됩니다. semSignal 연산은 세마포어 값을 증가시킵니다. 만약 값이 0이하이면 semSignal 연산에 의해 블록된 프로세스들을 깨웁니다. 이러한 세마포어는 카운팅 세마포어 / 이진 세마포어로 나뉩니다. 카운팅 세마포어는 앞서 말씀드린 것처럼 세마포어 변수 값이 0이상의 수입니다. 그에 비해 이진 세마포어는 초기값이 0 또는 1만 가능합니다. 이는 뮤텍스와 유사합니다.

뮤텍스는 임계영역에 들어갈 때 lock을 걸어 다른 프로세스가 접근하지 못하도록 막고, 임계영역에서 나왔을 때 해당 lock을 해제하는 방식입니다. 카운팅 세마포어와 달리 오직 한개의 프로세스만 자원에 접근할 수 있습니다.
