# CS_study_18회

## 1. [네트워크] http / https

HTTP는 응용 계층의 프로토콜로 TCP/IP 위에서 작동하며, www에서 html 문서를 송수신 하기 위한 표준 프로토콜입니다. HTTP를 통해 전송되는 데이터는 암호화되지 않았기 때문에 데이터가 보호되지 않는다는 문제점을 가지고 있습니다.

이를 보완하기 위해 HTTP에 secure의 S를 붙인 것이 HTTPS 입니다. 즉, HTTPS는 HTTP에서 보안 기능을 강화한 프로토콜입니다. HTTPS는 SSL 인증서를 사용하여 사용자가 사이트에 제공하는 정보를 공개키/개인키 암호화하여 보안을 유지합니다.

- 공개키 암호화: 개인키로만 복호화 -> 개인키는 본인만 가지고 있으므로 본인만 볼 수 있습니다.
- 개인키 암호화: 공개키로만 복호화 -> 개인의 신뢰성을 보장할 수 있습니다.

HTTP는 보안에 취약한 반면 속도가 빠르고, HTTPS는 보안성이 강한 반면 속도가 느린 단점이 있습니다.



## 2. [컴퓨터구조] 컴퓨터 덧셈기 / 뺄셈기

> 컴퓨터의 덧셈기, 뺄셈기의 동작 원리에 대해 설명해주세요.

우선 컴퓨터는 N개의 비트를 이용해 2^N의 정수만 표현할 수 있습니다. 따라서 사칙연산 또한 2진수로 처리합니다.

컴퓨터 내부에서 사칙연산을 할 때 덧셈의 경우 일반적인 2진수 덧셈방식을 사용합니다. 뺄셈의 경우 뺄셈기가 따로 존재하지 않기 때문에 보수를 이용하여 음수를 표현하고, 이를 더하는 방식으로 뺄셈을 수행합니다.

컴퓨터에서 음수를 표현하는 방법에는 1의 보수, 2의 보수가 있는데 뺄셈에서는 2의 보수를 이용하여 음수를 표현합니다.

1. 1의 보수
   - 각 자릿수의 값이 모두 1인 수에서 주어진 수를 뺀 수 입니다.
   - 예) 2진수 1010의 1의 보수 = 1111 - 1010 = 0101
   - 그러나 1의 보수를 사용할 경우 +0 = 0000, -0 = 1111 으로 0이 두개가 생기므로 컴퓨터의 뺄셈에서는 2의 보수를 사용합니다.
2. 2의 보수
   - 1의 보수에서 +1을 한 것입니다.
   - 예) 2진수 1010의 2의 보수 = 0101+1 = 0110

2의 보수를 이용한 뺄셈은 양수를 이진수로 표현하고, 음수를 2의 보수로 표현해서 더하면 됩니다.

예) 십진수 19 - 10 = 이진수 19 + (이진수 10의 2의 보수) = 00010011+11110110 = 00001001 = 십진수 9



## 3. [데이터베이스] 트랜잭션 격리수준

트랜잭션 격리 수준이란 DB에서 동시에 여러 트랜잭션이 처리될 때, 특정 트랜잭션이 다른 트랜잭션의 변경된 데이터를 볼 수 있는 정도를 뜻합니다.

DB는 무결성을 지키기 위해 동시에 처리되는 트랜잭션이 서로의 영향을 받지 못하도록 Locking을 할 수 있습니다. 그러나 모든 트랜잭션 처리에 대해 Locking 하게 되면 DB의 성능이 떨어지기 때문에 다양한 수준을 두고 Locking의 정도를 세분화했습니다. 이것이 바로 트랜잭션 격리 수준입니다.

1. Read Uncommitted (레벨 0)
   - 다른 트랜잭션이 현재 처리중인 트랜잭션이나 아직 Commit되지 않은 데이터를 읽는 것을 허용합니다. DB 처리의 동시성은 높아지지만 데이터의 일관성을 유지하는 것이 불가능합니다.
2. Read Committed (레벨 1)
   - SELECT 문장이 수행되는 동안 해당 데이터에 Shared Lock이 걸립니다. 즉, 트랜잭션이 처리되는 동안은 다른 트랜잭션이 접근할 수 없기 때문에 Commit이 이루어진 트랜잭션만 접근할 수 있습니다. Oracle에서 기본적으로 사용하는 수준입니다.
3. Repeatable Read (레벨 2)
   - 트랜잭션이 완료될 때까지 SELECT 문장이 사용되는 모든 데이터에 Shared Lock이 걸립니다. 다른 사용자는 트랜잭션 영역에 해당하는 데이터에 대한 수정이 불가능합니다. My SQL에서 기본적으로 사용하는 수준입니다.
4. Serializable (레벨 3)
   - 레벨 2에서 더 나아가 트랜잭션 영역에 해당하는 데이터에 대한 수정 및 입력이 불가능합니다. 따라서 완벽한 읽기 일관성 모드를 제공합니다.

격리 수준이 높아질 수록 트랜잭션간 고립 정도가 높아지기 때문에 DB 성능이 저하됩니다.



## 4. [알고리즘] Fibonacci

> Fibonacci에서의 재귀, 동적 프로그래밍, 반복의 세 가지 방식에 대한 시간복잡도와 공간복잡도를 말씀해주세요.

### 1. 재귀

```python
def fibonacci_recursive(n):
    if n <= 1:
        return 1
   	return fibonacci_recursive(n-2)+fibonacci_recursive(n-1)
```

재귀로 구현하는 방식의 경우 값을 구할 때마다 매번 첫 항 까지 도달해야하므로 시간복잡도는 O(2^n)입니다. 공간복잡도는 n에 따라 변수 n이 ❓개가 만들어지고, 스택에 쌓이게 되므로 O(❓)이 됩니다. (미완성)



### 2. 동적 프로그래밍

```python
def fibonacci_dp(n):
    DP = [0]*(n+1)
    if n < 2:
        return n
    for i in range(2, n+1):
        DP[n] = DP[n-1]+DP[n-2]
    return DP[n]
```

동적프로그래밍 방식으로 구현하는 경우, 재귀와 달리 memoization을 통해 이전에 구한 값들을 사용할 수 있으므로 O(n)의 시간복잡도를 가집니다. 공간복잡도는 memoization에 필요한 크기 (n+1)의 배열이 필요하므로 O(n)이라고 생각합니다.



### 3. 반복

```python
def fibonacci_loop(n):
    if n <= 1:
        return n
    a = 0
    b = 1
    answer = 0
    for i in range(2, n+1):
        answer = a+b
        a = b
        b = answer
    return answer
```

반복 방식으로 구현하는 경우 n번째 수를 구하려면 n번 반복하면 되기 때문에 O(n)의 시간복잡도를 가집니다. 공간복잡도의 경우 n번째 값을 한 변수에 재할당만 해주면 되기 때문에 O(1)이라고 생각합니다.

