# CS_study_19회

## 1. [알고리즘] Quick sort

퀵 정렬의 과정은 한 마디로 '피벗(pivot)이 자신의 자리를 찾아가며 정렬되는 과정'이라고 할 수 있을 것 같습니다.

퀵 정렬을 진행하기 위해 우선 가장 처음/중간/마지막 수 중 하나를 첫번째 피벗으로 선택합니다. 그 후 양 끝의 인덱스를 각각 i, j라고 정합니다. i는 오른쪽으로 이동하며 피벗보다 큰 수를 찾고, j는 왼쪽으로 이동하며 피벗보다 작은 수를 찾아 i와 j 요소를 서로 교환합니다. 이로써 피벗은 자신의 자리를 찾고, 피벗을 기준으로 왼쪽에 피벗보다 작은 수, 오른쪽에 피벗보다 큰 수를 배치하게 합니다. 이 후 양 쪽을 각각 퀵 정렬 하는 분할정복의 방법을 사용하여 정렬을 완료하게 됩니다.

이러한 퀵 정렬의 시간복잡도는 평균적으로 O(nlogn)이나, 최악의 경우 O(n^2)가 됩니다. 이는 수가 역순으로 정렬되어 있을 때 피벗을 가장 첫번째 수로 선택하는 경우입니다. 따라서 피벗을 중간 수로 선택한다면 최악의 시간복잡도를 피할 수 있습니다.



## 2. [데이터베이스] DB index

데이터베이스의 인덱스는 책의 색인처럼 원하는 정보를 빠르게 찾을 수 있도록 돕는 역할을 합니다.

- 인덱스의 동작 과정

  1. Index table에서 where에 포함된 값을 찾습니다.
  2. 해당 값의 table_id [PK]를 가져옵니다.
  3. 가져온 table_id [PK] 값으로 원본 테이블에서 값을 조회합니다.

- 데이터베이스 인덱스에서 주로 사용되는 알고리즘은 B+tree 알고리즘입니다.

  ![img](https://www-cdn.qwertee.io/media/uploads/btree.png)

  - B+tree의 구성
    - 리프 노드: 실제 데이터가 저장되는 노드
    - 논리 노드: 리프 노드까지의 경로 역할을 하는 노드
    - 루트 노드: 경로의 출발점 노드
  - B+Tree는 리프 노드에 이르기까지 자식 노드에 대한 포인터가 저장되어 있기 때문에 탐색 시 루트 노드에서 특정 리프 노드에 이르는 한 개의 경로만 검색하면 됩니다. 따라서 검색 시 매우 효율적입니다.

- 인덱스는 하나의 테이블을 별도로 생성하여 값을 저장하고 사용합니다. 즉, 의존적인 테이블이 하나 더 생기기 때문에 무분별한 인덱스 생성은 오히려 성능 저하를 초래할 수 있습니다. 



## 3. [컴퓨터구조] Big Endian / Little Endian

Endian은 여러 개의 연속된 대상을 배열하는 방법을 뜻합니다. Big Endian은 큰 단위가 앞에 나오며, Little Endian은 작은 단위가 앞에 나오는 방식입니다.

1. Big Endian
   - 사람이 숫자를 쓰는 방식과 동일합니다.
   - 일반적으로 네트워크 주소 표기에 Big Endian을 사용합니다.
2. Little Endian
   - 작은 단위의 바이트가 앞에 나오는 방식입니다.
   - 메모리에 저장된 값의 하위 바이트만 사용할 때 별도의 계산이 필요 없습니다.
   - 대표적으로 x86 아키텍처가 Little Endian을 사용합니다.

예를들어 저장하려는 데이터가 `0x12345678` 일 때,

Big Endian = 12 / 34 / 56 / 78

Little Endian = 78 / 56 / 34 / 12

이 됩니다.

