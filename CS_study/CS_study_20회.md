# CS_study_20회

## 1. [자료구조] Binary Tree

> 이진트리의 단점과 이를 보완한 자료구조에 대해 설명해주세요.

이진트리의 탐색 시간복잡도는 O(logN)으로 빠른 편이지만, 한쪽으로 노드가 치우쳐있을 때 시간복잡도가 일반 배열을 탐색하는 O(N)이 되어버리는 단점이 있습니다. 이를 보완하기 위한 자료구조로는 AVL 트리가 있습니다.

![img](https://blog.kakaocdn.net/dn/blxsRD/btq21CW9Fw3/WOk8F74J254K1pczckskEK/img.png)

AVL 트리는 스스로 균형을 잡는 이진탐색 트리로 왼쪽, 오른쪽 서브 트리의 높이 차이가 최대 1이 되기 때문에 삽입, 검색, 삭제의 시간 복잡도가 O(logN)이 됩니다.



## 2. [운영체제] 메모리 단편화

> 메모리 단편화와 해결 기법에 대해 설명해주세요.

메모리 단편화란 RAM에서 사용 가능한 메모리가 충분히 존재함에도 불구하고, 사용이 불가능한 상태를 의미합니다. 이러한 메모리 단편화는 두 종류가 있습니다.

1. 내부 단편화: 메모리 할당 시 프로세스가 필요한 양보다 더 큰 메모리가 할당되어 프로세스의 메모리 공간이 낭비되는 현상입니다.
2. 외부 단편화: 메모리의 할당 및 해제 작업의 반복으로 인해 작은 메모리가 중간 중간 존재하게 되어 총 메모리 공간은 충분하나 실제로 할당할 수 없는 현상입니다.

이러한 메모리 단편화의 해결 방법으로는

1. **페이징 기법 (Paging)**
   - 페이지: 보조기억장치를 이용한 가상메모리를 같은 크기의 블록으로 나눈 것
   - 프레임: RAM을 페이지와 같은 크기로 나눈 것
   - 사용하지 않는 프레임을 페이지에 옮기고, 필요한 메모리를 페이지 단위로 프레임에 옮기는 기법입니다. 페이지-프레임을 대응시키기 위해 page mapping이 필요합니다.
   - 페이징 기법을 사용하면 연속적이지 않은 공간도 활용할 수 있어 외부 단편화 문제를 해결할 수 있습니다. 그러나 페이지 단위에 알맞게 꽉 채워 쓰는게 아니므로 내부 단편화 문제는 여전히 존재합니다.
2. **세그멘테이션 기법 (Segmentation)**
   - 가상메모리를 서로 크기가 다른 논리적 단위인 세그먼트로 분할하여 메모리를 할당, 실제 메모리 주소로 변환합니다.
   - 각 세그먼트의 크기가 다르기 때문에 미리 분할하지 않고 메모리 적재 시 빈 공간을 찾아 할당합니다.
   - mapping을 위해 세그먼트 테이블이 필요합니다.
   - 프로세스가 필요한 메모리 만큼 할당해주기 때문에 내부단편화를 방지할 수 있으나, 외부 단편화 문제는 여전히 존재합니다.
3. **메모리 풀 (Memory pool)**
   - 메모리 공간을 필요한 크기, 개수만큼 사용자가 직접 지정하여 미리 할당받아 놓고 필요할 때마다 사용 및 반납하는 기법입니다.
   - 미리 공간을 할당해놓고 사용하기 때문에 할당-해제로 인한 외부 단편화가 발생하지 않습니다. 또한, 필요한 크기 만큼 할당을 해놓기 때문에 내부 단편화 또한 생기지 않습니다.
   - 그러나 메모리 단편화로 인한 메모리 낭비량보다 메모리 풀을 만들었지만 사용하지 않을 때의 메모리 양이 커질 경우 비효율적입니다.



## 3. [데이터베이스] SQL / NoSQL

1. SQL
   - Structured Query Language의 약자로 데이터베이스(특히 관계형 데이터베이스)와 상호작용을 위해 사용하는 언어입니다.
   - 관계형 데이터는 엄격한 스키마를 가지고 있기 때문에 스키마를 준수하지 않는 레코드는 추가할 수 없습니다.
   - 또한, 하나의 테이블에서 중복 없이 하나의 데이터만을 관리하며 다른 테이블과의 관계를 통해 필요한 데이터를 도출합니다.
   - 엄격한 구조로 인해 수평적 확장이 어렵고 수직적 확장만 가능하다는 단점이 존재합니다.
2. NoSQL
   - SQL과 반대되는 접근 방식을 따르기 때문에 스키마와 관계가 존재하지 않습니다. 또한, SQL에서는 정해진 스키마를 따르지 않는다면 데이터를 추가할 수 없지만 NoSQL에서는 다른 구조의 데이터를 같은 컬렉션(=SQL의 테이블)에 추가할 수 있습니다.
   - 레코드는 JSON 데이터와 유사한 형태를 띠고 있기 때문에 레코드의 형태에 좀 더 유연합니다.
   - NoSQL에서는 조인의 개념이 없으며 데이터를 복제하여 필요한 데이터를 도출합니다. 따라서 데이터가 여러 컬렉션에 중복되어 있기 때문에 수정을 해야하는 경우 모든 컬렉션에서 수정을 해야하는 번거로움이 있습니다.
   - 수평적 확장에 용이하다는 장점을 가지고 있습니다.



## 4. [알고리즘] Merge sort

> Merge sort의 장단점과 일어나는 과정을 설명해주세요.

- Merge sort는 요소를 더 이상 쪼갤 수 없을 때까지 절반씩 나눈 후, 정렬을 진행하는 분할정복 방식의 정렬 방법입니다.
- 재귀 형태로 구현하기 쉬운 방식이며 시간복잡도는 O(NlogN)입니다.
- 장점: pivot의 위치에 따라 성능 차이가 발생하는 퀵정렬과 달리 항상 일정한 속도를 가지고 있습니다.
- 단점: 정렬을 하기 위해서는 데이터 전체 만한 메모리가 더 필요하여 공간이 많이 필요합니다.