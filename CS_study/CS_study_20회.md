# CS_study_20회

## 1. [자료구조] Binary Tree

> 이진트리의 단점과 이를 보완한 자료구조에 대해 설명해주세요.

이진트리의 탐색 시간복잡도는 O(logN)으로 빠른 편이지만, 한쪽으로 노드가 치우쳐있을 때 시간복잡도가 일반 배열을 탐색하는 O(N)이 되어버리는 단점이 있습니다. 이를 보완하기 위한 자료구조로는 AVL 트리가 있습니다.

![img](https://blog.kakaocdn.net/dn/blxsRD/btq21CW9Fw3/WOk8F74J254K1pczckskEK/img.png)

AVL 트리는 스스로 균형을 잡는 이진탐색 트리로 왼쪽, 오른쪽 서브 트리의 높이 차이가 최대 1이 되기 때문에 삽입, 검색, 삭제의 시간 복잡도가 O(logN)이 됩니다.



## 2. [운영체제] 메모리 단편화

> 메모리 단편화와 해결 기법에 대해 설명해주세요.

메모리 단편화란 RAM에서 사용 가능한 메모리가 충분히 존재함에도 불구하고, 사용이 불가능한 상태를 의미합니다. 이러한 메모리 단편화는 두 종류가 있습니다.

1. 내부 단편화: 메모리 할당 시 프로세스가 필요한 양보다 더 큰 메모리가 할당되어 프로세스의 메모리 공간이 낭비되는 현상입니다.
2. 외부 단편화: 메모리의 할당 및 해제 작업의 반복으로 인해 작은 메모리가 중간 중간 존재하게 되어 총 메모리 공간은 충분하나 실제로 할당할 수 없는 현상입니다.

이러한 메모리 단편화의 해결 방법으로는

1. **페이징 기법 (Paging)**
   - 페이지: 보조기억장치를 이용한 가상메모리를 같은 크기의 블록으로 나눈 것
   - 프레임: RAM을 페이지와 같은 크기로 나눈 것
   - 사용하지 않는 프레임을 페이지에 옮기고, 필요한 메모리를 페이지 단위로 프레임에 옮기는 기법입니다. 페이지-프레임을 대응시키기 위해 page mapping이 필요합니다.
   - 페이징 기법을 사용하면 연속적이지 않은 공간도 활용할 수 있어 외부 단편화 문제를 해결할 수 있습니다. 그러나 페이지 단위에 알맞게 꽉 채워 쓰는게 아니므로 내부 단편화 문제는 여전히 존재합니다.
2. **세그멘테이션 기법 (Segmentation)**
   - 가상메모리를 서로 크기가 다른 논리적 단위인 세그먼트로 분할하여 메모리를 할당, 실제 메모리 주소로 변환합니다.
   - 각 세그먼트의 크기가 다르기 때문에 미리 분할하지 않고 메모리 적재 시 빈 공간을 찾아 할당합니다.
   - mapping을 위해 세그먼트 테이블이 필요합니다.
   - 프로세스가 필요한 메모리 만큼 할당해주기 때문에 내부단편화를 방지할 수 있으나, 외부 단편화 문제는 여전히 존재합니다.
3. **메모리 풀 (Memory pool)**
   - 메모리 공간을 필요한 크기, 개수만큼 사용자가 직접 지정하여 미리 할당받아 놓고 필요할 때마다 사용 및 반납하는 기법입니다.
   - 미리 공간을 할당해놓고 사용하기 때문에 할당-해제로 인한 외부 단편화가 발생하지 않습니다. 또한, 필요한 크기 만큼 할당을 해놓기 때문에 내부 단편화 또한 생기지 않습니다.
   - 그러나 메모리 단편화로 인한 메모리 낭비량보다 메모리 풀을 만들었지만 사용하지 않을 때의 메모리 양이 커질 경우 비효율적입니다.