# CS_study_21회

## 1. [알고리즘] Greedy

> Greedy 알고리즘에 대해 설명하고, 단점과 사용하는 상황을 설명해주세요.

Greedy 알고리즘이란 여러 경우 중 하나를 결정해야 할 때 마다 매순간 최적이라고 생각되는 경우를 선택하여 최종적인 값을 구하는 알고리즘입니다.

Greedy 알고리즘의 단점으로는 근사치 추정에 활용될뿐 반드시 최적의 해 자체를 구할 수는 없다는 점입니다.

Greedy 알고리즘을 사용하는 상황은 다음의 조건을 만족하는 상황입니다.

1. Greedy choice property: 앞의 선택이 이후의 선택에 영향을 주지 않습니다.
2. Optimal substructure: 문제 전체에 대한 최적해가 부분 문제에 대해서도 역시 최적해가 됩니다.



## 2. [자료구조] Stack / Queue

> 스택과 큐에 대해 설명하고 사용되는 예시를 말씀해주세요.

스택과 큐는 둘 다 선형 자료구조라는 점에서 공통점을 갖습니다.

스택은 LIFO(Last In First Out) 구조로 가장 마지막에 삽입된 요소가 가장 먼저 나오는 구조입니다. 일상생활에서 사용되는 예시로는 뷔페에서의 접시더미가 있으며, 컴퓨터 공학에서의 예시는 브라우저의 '뒤로 가기' 기능이 있습니다. 알고리즘적으로는 DFS에 활용합니다.

큐는 FIFO(First In First Out) 구조로 가장 처음 삽입된 요소가 가장 먼저 나오는 구조입니다. 일상생활에서 사용되는 예시로는 대기줄이 있으며, 컴퓨터 공학에서의 예시는 캐시(Cache)가 있습니다. 알고리즘적으로는 BFS에 활용합니다.



## 3. [운영체제] Mutex / Semaphore

뮤텍스와 세마포어는 다수의 프로세스나 스레드가 공유 자원에 동시에 접근하는 것을 제어하는 방법입니다.

뮤텍스는 임계영역에 들어갈 때 lock을 걸어 다른 프로세스가 접근하지 못하도록 막고, 임계영역에서 나왔을 때 해당 lock을 해제하는 방식입니다. 세마포어 중 카운팅 세마포어와 달리 오직 한개의 프로세스만 자원에 접근할 수 있습니다.

세마포어는 세마포어 변수, Wait 연산, Signal연산으로 이루어져 있습니다. 세마포어 변수는 정수로 해당 정수 값 만큼 사용자 동시 접근을 할 수 있습니다. Wait연산은 세마포어 값을 감소시킵니다. 값이 음수가 되면 Wait를 호출한 프로세스는 블록됩니다. Signal 연산은 세마포어 값을 증가시킵니다. 만약 값이 0이하이면 Signal 연산에 의해 블록된 프로세스들을 깨웁니다. 이러한 세마포어는 카운팅 세마포어 / 이진 세마포어로 나뉩니다. 카운팅 세마포어는 앞서 말씀드린 것처럼 세마포어 변수 값이 0이상의 수입니다. 그에 비해 이진 세마포어는 초기값이 0 또는 1만 가능합니다. 이는 뮤텍스와 유사합니다.



## 4. [네트워크] HTTP 1.1 / HTTP 2.0

![img](https://blog.kakaocdn.net/dn/B2nxo/btqF1Tf9r06/Y1kDK62YrhAkRIlA4wUe41/img.gif)

HTTP 1.1은 연결 당 하나의 요청과 응답을 처리하는 방식입니다.

이러한 HTTP 1.1의 문제점으로는

1. 동시 전송 문제와 다수의 리소스를 처리하는데 속도, 성능 이슈가 존재합니다.
2. 먼저 받은 요청이 끝나지 않으면 그 뒤의 요청 처리가 끝나더라도 먼저 온 요청이 끝날 때까지 기다려야 합니다. 따라서 특정 응답 지연 문제인 HOL(Head Of Line) 문제가 발생합니다.
3. RTT(Round Trip Time, 네트워크 시작 지점->대상->시작으로 이동하는데 걸리는 시간) 증가하여 양방향 지연 문제가 발생합니다.
4. 헤더가 크기 때문에 매 요청 마다 중복된 헤더 값을 전송하게 됩니다.

이러한 문제점을 보완하는 HTTP 2.0이 등장했습니다. HTTP 2.0의 특징으로는

1. 하나의 연결 당 여러 메시지를 동시에 주고 받을 수 있습니다.
2. 요청이 연결 상에서 다중화되므로 HOL 문제가 발생하지 않습니다.
3. 헤더 정보를 압축하여 전송합니다.

이러한 특징을 바탕으로 HTTP 1.1의 성능 및 속도 문제를 개선했습니다.

