# CS_study_22회

## 1. [알고리즘] Heap

> Heap에 대해 설명하고 삽입, 삭제 과정을 설명해주세요.

- 힙은 각 노드의 값이 자식의 키 값보다 작지 않거나(최대 힙) 크지 않은(최소 힙) 완전 이진 트리입니다. 최댓값, 최솟값을 찾아내는 연산을 쉽게 하기 위해 고안된 자료형입니다.
- 삽입 과정
  - 힙은 완전이진트리의 구조를 유지해야 하므로 삽입 시 트리의 가장 마지막에 원소를 추가합니다.
  - 삽입된 형태의 힙이 힙의 조건을 만족하는지 확인합니다.
  - 조건에 맞을 때까지 부모 노드와 위치를 맞바꾸는 것을 반복합니다.
- 삭제 과정
  - 삭제 연산은 루트노드에서만 이루어집니다.
  - 완전이진트리를 유지하기 위해 트리의 가장 마지막 노드를 루트로 옮깁니다.
  - 루트로 옮겨진 노드와 두 자식노드 중 더 큰 값을 가지는 노드와 비교합니다.
  - 힙 조건을 만족하지 않을 시 조건을 만족할 때까지 자식 노드와의 비교, 값 맞바꿈을 반복합니다.



## 2. [자료구조] Graph

> Graph 자료구조에 대해 설명하고 구현 방법을 설명해주세요.

### 1. 그래프 개념

- 그래프란 정점과 간선으로 이루어진 자료구조입니다.
- 트리와 함께 비선형구조로 분류됩니다. 하지만 트리와 달리 정점마다 간선이 있을 수도 없을 수도 있으며, 루트 노드와 부모, 자식 개념이 존재하지 않습니다.
- 지하철 노선도, 도심의 도로 등에 사용되는 실생활과 밀접한 자료구조 입니다.



### 2. 그래프 구현 방법

1. 인접행렬(Adjacency Materix)
   - 그래프의 노드를 2차원 배열로 만든 것입니다.
   - 정점 간 간선이 존재하면 1을, 그렇지 않으면 0을 넣어줍니다.
   - 장점
     - 2차원 배열 안에 모든 정점의 간선 정보를 담기 때문에 배열의 위치를 확인하면 두 점에 대한 연결 정보 조회 시 O(1)의 시간복잡도면 가능합니다.
     - 구현이 비교적 간편합니다.
   - 단점
     - 모든 정점에 대한 간선 정보를 대입해야 하므로 O(N^2)의 시간복잡도가 소요됩니다.
     - 무조건 2차원 배열이 필요하기 때문에 공간 낭비가 심합니다.
2. 인접리스트(Adjacency List)
   - 정점별 리스트를 만들어 해당 정점과 연결된 정점들을 삽입하는 방법입니다.
   - 장점
     - 정점 간 연결 정보 탐색 시 O(N)의 시간복잡도가 소요됩니다.
     - 상대적으로 공간이 절약됩니다.
   - 단점
     - 특정 두 점의 연결 여부를 확인할 때 인접행렬에 비해 시간이 오래 걸립니다.
     - 구현이 비교적 복잡합니다.



## 3. [운영체제] fork() / exec()

1. fork() : 실행 중인 프로세스를 복사하는 함수입니다.
   - fork() 호출 시 프로세스 제어 블록(PCB)을 포함한 부모 프로세스 대부분이 자식 프로세스에 복사됩니다.
     - 💡 프로세스 제어 블록(PCB)이란?
       - 각각의 프로세스가 가지고 있는 정보입니다.
       - 운영체제가 관리할 때 필요한 정보 (프로세스 상태, 프로세스 구분자, 우선순위)
       - CPU 수행과 관련된 하드웨어 정보
       - 메모리 관련 정보 (코드, 데이터, 스택의 위치 정보)
       - 파일 관련 정보
   - PCB 중 변경되는 세 가지는 다음과 같습니다.
     1. 프로세스 구분자(PID): 사람의 주민등록번호가 모두 다르듯 복사한 프로세스도 명백히 다른 프로세스이므로 다른 PID를 가집니다.
     2. 메모리 관련 정보: 부모 프로세스와 자식 프로세스가 차지하는 메모리 위치가 다르기 때문입니다.
     3. 부모 프로세스 구분(PPID)와 자식 프로세스 구분자(CPID): 자식 프로세스의 자식이 없다고 가정하면 자식 프로세스의 CPID는 -1입니다. 부모 프로세스의 CPID는 자식 프로세스의 PID가 됩니다.
2. exec(): 프로세스의 전환으로 복사한 프로세스에 새로운 내용을 덮는 함수입니다.
   - 부모 프로세스의 PCB 등 복사된 것을 재활용할 수 있어 편리합니다.
   - 코드 영역만 새롭게 가져오면 되기 때문에 운영체제의 작업이 편리해집니다.
   - 동작 과정
     1. exec() 시스템 콜이 호출 됩니다.
     2. 코드 영역의 기존 내용이 지워지고 새로운 코드로 변경됩니다.
     3. 데이터 영역이 새로운 변수로 채워지고 스택 영역이 리셋됩니다.
     4. PCB 중 PID/PPID/CPID는 변하지 않지만 프로그램 카운터 값을 비롯한 각종 레지스터나 파일 정보는 리셋됩니다.
        - 💡 프로그램 카운터란?
          - 책갈피와 비슷한 개념으로 CPU가 해당 프로그램 코드를 어디까지 읽었는지 기록해둔 것입니다.



## 4. [웹] RESTful API

- RESTful API의 REST는 HTTP를 용도에 맞게 최대한 활용할 수 있도록 구성한 아키텍처입니다. 자원, 행동, 표현으로 구성됩니다.
  - 자원: URI는 정보의 자원을 표현합니다.
  - 행동: 하고자 하는 행동(CRUD)은 HTTP method로 표현합니다.
  - 표현: 요청에 따른 응답은 JSON 혹은 XML로 보내는 것이 일반적입니다.
- 가령 '1번 글을 삭제하는 API'를 설계할 때 REST를 지킨다면 'text/1/' 이라는 URI에 DELETE 메서드로 요청해야 합니다. 반면 'text/1/delete/' 처럼 URI에서 해당 자원에 대해 어떤 행위를 할지 확인할 수 있다면 RESTful한 API라고 할 수 없습니다.
- REST의 장점
  1. HTTP 프로토콜 인프라를 그대로 사용하므로 REST API 사용을 위한 별도의 인프라를 구축할 필요가 없습니다.
  2. HTTP 표준 프로토콜에 따르는 모든 플랫폼에서 사용이 가능합니다.
  3. REST API 메시지가 의도하는 바를 명확하게 나타내므로 의도하는 바를 쉽게 파악할 수 있습니다.
  4. 서버와 클라이언트의 역할을 명확하게 분리합니다.
- REST의 단점
  1. 표준이 존재하지 않습니다.
  2. HTTP Method가 제한적입니다.