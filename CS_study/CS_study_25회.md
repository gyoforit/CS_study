# CS_study_25회

## 1. [알고리즘] Bellman-Ford

### 1. 개념

- 벨만 포드 알고리즘은 최단 경로를 찾는 알고리즘 중 하나로, 음수 간선이 존재하는 경우에 사용하는 알고리즘입니다. 또한, 음수 간선의 순환을 감지할 수 있습니다.

### 2. 동작 과정 및 시간복잡도

> V: 정점 개수, E: 간선 개수

1. 출발 노드를 설정합니다.
2. 노드별 최단 거리를 갱신하는 배열을 초기화합니다.
3. 다음의 과정을 (V-1)번 반복합니다.
   1. 전체 간선 E개를 하나씩 확인합니다.
   2. 각 간선을 거쳐 다른 노드로 가는 비용을 계산하여 최단 거리 배열을 갱신합니다.
4. V번째 조회: 만약 음수 간선 순환이 발생하는지 체크하고 싶다면 3번의 과정을 한 번 더 수행합니다.
   - 최단 거리 테이블이 갱신된다면 음수 간선 순환이 존재하는 것입니다.

- 벨만 포드 알고리즘의 시간 복잡도는 O(VE) 입니다.

### 3. 다익스트라 vs 벨만 포드 비교

1. 다익스트라
   - 매번 방문하지 않은 노드 중에서 최단 거리가 가장 짧은 노드를 선택합니다.
   - 음수 간선이 없다면 최적의 해를 찾을 수 있습니다.
2. 벨만 포드
   - 매번 모든 간선을 전부 확인합니다.
   - 다익스트라 알고리즘에 비해 시간이 오래 걸리지만 음수 간선 순환을 탐지할 수 있습니다.



## 2. [자료구조] Minimum Spanning Tree

### 1. 개념

- 가중치 그래프에서 싸이클 없이 모든 점을 연결시킨 트리 중 가중치 합이 최소인 트리를 의미합니다.
- 그래프의 점 개수가 N개면 신장트리에는 (N-1)개의 간선이 존재합니다.
- 최소 신장 트리에 대한 대표적인 알고리즘으로는 Kruskal, Prim 알고리즘이 있습니다.



### 2. Kruskal

1. 가중치의 오름차순으로 간선들을 정렬합니다.
2. 선택된 간선 개수 < (정점 개수-1) 인 동안 다음을 반복합니다.
   1. 가장 작은 가중치를 가진 간선을 가져옵니다.
   2. 해당 간선이 기존의 신장트리와 싸이클을 형성하지 않으면 신장트리에 추가합니다.
3. Kruskal 알고리즘의 시간복잡도는 O(mlogm)입니다. (m: 간선 개수)
   - 반복문은 최대 m번 수행되며, 각 간선이 싸이클을 형성하는지 검사하는데 logm시간이 걸리기 때문입니다.



### 3. Prim

1. 최소 가중치를 저장해 둘 배열 D를 생성합니다.
2. 임의의 점 p를 골라 D[p] = 0으로 초기화 합니다.
3. 점 p가 아닌 각 점들에 대해 p-v를 잇는 간선이 있다면 D[v]를 해당 간선 가중치로 초기화합니다. 그렇지 않은 점은 무한대로 초기화합니다.
4. 트리의 크기 < (정점 개수) 인 동안 다음을 반복합니다.
   1. 트리에 속하지 않은 각 점들에 대해 가중치 값이 최소인 간선을 트리에 추가합니다.
   2. 해당 점까지의 거리를 최소 가중치값과 비교하여 더 작은 값으로 갱신합니다.
5. Prim 알고리즘의 시간복잡도는 O(n^2)입니다. (n: 정점 개수)
   - 반복문이 (n-1)번 반복되고 각 반복에서 가중치 최솟값을 찾을 때 n만큼 걸리기 때문입니다.



## 3. [운영체제] Deadlock 해결

### 1. 교착 상태 예방 (Deadlock Prevention)

> 교착 상태가 되지 않도록 하는 방법입니다.

1. 상호 배제 부정: 읽기 전용 파일과 같은 공유 자원을 사용합니다.
2. 점유 및 대기 부정
   - 프로세스 대기를 없애기 위해 프로세스가 실행되기 전 필요한 모든 자원을 할당합니다. 이는 자원이 낭비될 수 있습니다.
   - 자원을 점유하지 않을 때에만 다른 자원을 요청하도록 합니다. 이는 기아상태를 야기할 수 있습니다.
3. 비선점 부정
   - 모든 자원에 대한 선점을 허용합니다.
   - 프로세스가 할당받을 수 없는 자원을 요청하는 경우, 기존에 가진 자원을 모두 반납하고 새 자원과 이전 자원을 얻기 위해 대기하도록 합니다.
4. 순환 대기 부정: 자원에 고유한 번호를 할당하고 번호 순서대로 자원을 요구하도록 합니다.



### 2. 교착 상태 회피 (Deadlock Avoidance)

> 교착 상태가 발생하기 전에 교착 상태를 예상하여 안전한 상태에서만 자원 요청을 허용하는 방법입니다.

1. 교착 상태 회피를 위한 가정
   1. 프로세스 수가 고정되어 있어야 합니다.
   2. 자원의 종류와 수가 고정되어 있어야 합니다.
   3. 프로세스가 요구하는 자원 및 최대 자원의 수를 알아야 합니다.
   4. 프로세스는 반드시 자원을 사용 후 반납해야 합니다.
2. 자원 할당 그래프 알고리즘 (Resource-Allocation Graph Algorithm)
   1. 자원 할당 그래프에 예약 간선을 추가합니다. (향후 요청할 수 있는 자원을 가리키는 점선 간선)
   2. 프로세스 시작 전 모든 예약 간선들을 자원할당 그래프에 표시합니다.
   3. 프로세스는 예약 간선으로 설정한 자원에 대해서만 요청할 수 있고 싸이클이 형성되지 않을 때에만 자원을 할당받습니다.
3. 은행원 알고리즘 (Banker's Algorithm)
   1. 프로세스 시작 시 자신이 필요한 각 자원의 최대 개수를 미리 선언합니다.
   2. 각 프로세스에서 자원 요청이 있을 때 요청을 승인하면 시스템이 안전한 상태로 유지되는 경우에만 자원을 할당합니다.
   3. 불안정 상태가 예상되면 다른 프로세스가 끝날 때까지 기다립니다.



### 3. 교착 상태 탐지 (Deadlock Detection)

- 탐지 알고리즘을 사용하여 교착 상태가 발생했는지 탐지합니다.

- 교착 상태가 탐지되었다면 복구 기법을 통해 교착상태를 복구합니다.
- 탐지 알고리즘은 오버헤드가 있기 때문에 호출 빈도를 적절히 조절해야 합니다.



### 4. 교착 상태 복구 (Deadlock Recovery)

1. 프로세스 종료
   - 교착 상태에 있는 프로세스를 종료하는 방식입니다. 두 가지 방식이 있습니다.
     1. 교착 상태의 프로세스 모두 종료
     2. 교착 상태가 제거될 때까지 한 프로세스씩 종료
2. 자원 선점
   - 교착 상태에 있는 프로세스가 점유하는 자원을 선점하여 다른 프로세스에게 할당 후, 해당 프로세스를 일시 정지합니다.
   - 자원 선점에 있어 고려해야 할 것은 세 가지 입니다.
     1. 희생자 선택: 최소의 피해를 줄 수 있는 프로세스를 선택합니다.
     2. 롤백: 선점된 프로세스를 문제 없던 이전의 상태로 롤백합니다.
     3. 기아 상태: 한 프로세스가 계속 선점되어 기아상태가 되는 것을 방지해야 합니다.