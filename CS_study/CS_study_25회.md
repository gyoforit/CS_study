# CS_study_25회

## 1. [알고리즘] Bellman-Ford

### 1. 개념

- 벨만 포드 알고리즘은 최단 경로를 찾는 알고리즘 중 하나로, 음수 간선이 존재하는 경우에 사용하는 알고리즘입니다. 또한, 음수 간선의 순환을 감지할 수 있습니다.

### 2. 동작 과정 및 시간복잡도

> V: 정점 개수, E: 간선 개수

1. 출발 노드를 설정합니다.
2. 노드별 최단 거리를 갱신하는 배열을 초기화합니다.
3. 다음의 과정을 (V-1)번 반복합니다.
   1. 전체 간선 E개를 하나씩 확인합니다.
   2. 각 간선을 거쳐 다른 노드로 가는 비용을 계산하여 최단 거리 배열을 갱신합니다.
4. V번째 조회: 만약 음수 간선 순환이 발생하는지 체크하고 싶다면 3번의 과정을 한 번 더 수행합니다.
   - 최단 거리 테이블이 갱신된다면 음수 간선 순환이 존재하는 것입니다.

- 벨만 포드 알고리즘의 시간 복잡도는 O(VE) 입니다.

### 3. 다익스트라 vs 벨만 포드 비교

1. 다익스트라
   - 매번 방문하지 않은 노드 중에서 최단 거리가 가장 짧은 노드를 선택합니다.
   - 음수 간선이 없다면 최적의 해를 찾을 수 있습니다.
2. 벨만 포드
   - 매번 모든 간선을 전부 확인합니다.
   - 다익스트라 알고리즘에 비해 시간이 오래 걸리지만 음수 간선 순환을 탐지할 수 있습니다.



## 2. [자료구조] Minimum Spanning Tree

### 1. 개념

- 가중치 그래프에서 싸이클 없이 모든 점을 연결시킨 트리 중 가중치 합이 최소인 트리를 의미합니다.
- 그래프의 점 개수가 N개면 신장트리에는 (N-1)개의 간선이 존재합니다.
- 최소 신장 트리에 대한 대표적인 알고리즘으로는 Kruskal, Prim 알고리즘이 있습니다.



### 2. Kruskal

1. 가중치의 오름차순으로 간선들을 정렬합니다.
2. 선택된 간선 개수 < (정점 개수-1) 인 동안 다음을 반복합니다.
   1. 가장 작은 가중치를 가진 간선을 가져옵니다.
   2. 해당 간선이 기존의 신장트리와 싸이클을 형성하지 않으면 신장트리에 추가합니다.
3. Kruskal 알고리즘의 시간복잡도는 O(mlogm)입니다. (m: 간선 개수)
   - 반복문은 최대 m번 수행되며, 각 간선이 싸이클을 형성하는지 검사하는데 logm시간이 걸리기 때문입니다.



### 3. Prim

1. 최소 가중치를 저장해 둘 배열 D를 생성합니다.
2. 임의의 점 p를 골라 D[p] = 0으로 초기화 합니다.
3. 점 p가 아닌 각 점들에 대해 p-v를 잇는 간선이 있다면 D[v]를 해당 간선 가중치로 초기화합니다. 그렇지 않은 점은 무한대로 초기화합니다.
4. 트리의 크기 < (정점 개수) 인 동안 다음을 반복합니다.
   1. 트리에 속하지 않은 각 점들에 대해 가중치 값이 최소인 간선을 트리에 추가합니다.
   2. 해당 점까지의 거리를 최소 가중치값과 비교하여 더 작은 값으로 갱신합니다.
5. Prim 알고리즘의 시간복잡도는 O(n^2)입니다. (n: 정점 개수)
   - 반복문이 (n-1)번 반복되고 각 반복에서 가중치 최솟값을 찾을 때 n만큼 걸리기 때문입니다.